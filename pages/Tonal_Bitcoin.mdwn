[[!template id=delete]]

Tonal Bitcoin is a representation of the Bitcoin network aimed toward the minority of people who use the Tonal number system.
This is an alternative to decimal and the metric system, which improves usability drastically by allowing for infinite binary division (note that Bitcoin protocol support is still finite).
For more information on the Tonal system in general, please see [the book](http://www.lulu.com/product/file-download/tonal-system/10991091).

Please note, that all numbers of TBC and its divisions/multipliers are written in [Tonal](http://en.wikipedia.org/wiki/Tonal_System), not decimal.
This means that instead of counting 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- you count: 0, 1, 2, 3, 4, 5, 6, 7, 8, , 9, , , , , , 10. Some higher-value digits may require installing a [font](http://luke.dashjr.org/education/tonal/glyphs/fonts/).



style="background-color:silver"|Abbreviation|Pronunciation|[[Tonal (TBC)|Tonal_Bitcoin]]|Decimal (BTC)
|---|---|---|---
||Tam-Bitcoin|1 0000 0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|2 814 749.767 106 56
|ᵇTBC|Bong-Bitcoin|1 0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|42.949 672 96
|ᵐTBC|Mill-Bitcoin|1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|2.684 354 56
|ˢTBC|San-Bitcoin|100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|0.167 772 16
|ᵗTBC|Ton-Bitcoin|10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|0.010 485 76
|TBC|Bitcoin*|1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|0.000 655 36
|TBCᵗ|Bitcoin-ton|0.1&nbsp;&nbsp;&nbsp;|0.000 040 96
|TBCˢ|Bitcoin-san|0.01&nbsp;&nbsp;|0.000 002 56
|TBCᵐ|Bitcoin-mill|0.001&nbsp;|0.000 000 16
|TBCᵇ|Bitcoin-bong|0.0001|0.000 000 01


<small>* Tonal Bitcoin and Decimal Bitcoin can be differentiated by the pronunciation of the numbers. "One bitcoin", "two bitcoin", etc is decimal, but "an bitcoin", "de bitcoin" is tonal.</small>

The total number of Tonal Bitcoins ever (analogous to the 21mil BTC) is just over 7.75059 tam-bitcoin.

## Compatible Clients

While all Bitcoin clients will correctly approximate values in decimal bitcoin, actual Tonal compatibility is sparse.

* [[Spesmilo]], despite its name, can be configured to display TBC

## Guessing TBC or BTC

Given variable 'value' in base units (uBTCents/TBCᵇ), one can guess whether it is properly Decimal Bitcoin or Tonal Bitcoin with the following pseudo-code:

	if ( ! ( this % 0x10000 ) )
	Choose Tonal Bitcoin
	if ( ! ( this % 1000000 ) )
	Choose Decimal Bitcoin
	if ( ! ( this % 0x100 ) )
	Choose Tonal Bitcoin

### Python

<pre>import math

def formatBTC(n, addSign = False):
	s = "%0.2f BTC" % (math.ceil(n * 100) / 100.,)
	if addSign and n >= 0:
		s = "+" + s
	return s

def Bitcoin2BTC(n):
	return n / 100000000.

toTonalDict = dict(((57, u'\ue9d9'), (65, u'\ue9da'), (66, u'\ue9db'), (67, u'\ue9dc'), (68, u'\ue9dd'), (69, u'\ue9de'), (70, u'\ue9df'), (97, u'\ue9da'), (98, u'\ue9db'), (99, u'\ue9dc'), (100, u'\ue9dd'), (101, u'\ue9de'), (102, u'\ue9df')))

def formatTBC(n, addSign = False):
	s = "%x" % n
	n %= 1
	if n:
		s += '.'
		while n:
			n *= 16
			s += "%x" % n
			n %= 1
	s = unicode(s).translate(toTonalDict)
	s += " TBC"
	if addSign and n >= 0:
		s = "+" + s
	return s

def Bitcoin2TBC(n):
	return n / 65536.

def formatBitcoin(n, addSign = False):
	if not n % 0x10000:
		return formatTBC(Bitcoin2TBC(n), addSign);
	if not n % 1000000:
		return formatBTC(Bitcoin2BTC(n), addSign);
	if not n % 0x100:
		return formatTBC(Bitcoin2TBC(n), addSign);
	s = "%d uBTCents" % (n,);
	if addSign and n > 0:
		s = "+" + s;
	return s;</pre>

## Criticism

* [Davout](User:Davout) has to google this page each time someone mentions an amount in tonal bitcoin

### Can be done without funny characters

The tonal notation requires extra fonts.  Within the programming community there is a widely accepted convention for hexadecimal notation: use A-F for the higher order digits.  Thus, one counts 0,1,2,3, ... , 9,A,B,C,D,E,F,10,11 ....  There are even two conventions, (which are lacking in tonal) for distinguishing a base-16 number from a decimal.  The C convention prefixes 0x and the Motorola convention suffixes h.  So, the number san, 256 (decimal) would be written 0x100 or 100h.  In tonal notation, it would only be written 100, and thus potentially confused with decimal 100 which is 0x64.

Thus programming notation accomplishes the same goals as tonal notation with no requirement for changing fonts, thus is more suited to wide usage.  Further the prefix and suffix conventions lead to less ambiguity.
