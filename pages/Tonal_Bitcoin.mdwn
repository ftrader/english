Please note, that all numbers of TBC and its divisions/multipliers are written in [Tonal](http://en.wikipedia.org/wiki/John_W._Nystrom#Tonal_System_.28Hexadecimal.29), not decimal.
This means that instead of counting 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- you count: 0, 1, 2, 3, 4, 5, 6, 7, 8, , 9, , , , , , 10. Some higher-value digits may require installing a [font](http://luke.dashjr.org/education/tonal/glyphs/fonts/).



|TBCᵇ|0.00000001|0.0001|BitCoin-bong
|TBCᵐ|0.00000016|0.001|BitCoin-mill
|TBCˢ|0.00000256|0.01|BitCoin-san
|TBCᵗ|0.00004096|0.1|BitCoin-ton
|TBC|0.00065536|1|BitCoin*
|ᵗTBC|0.01048576|10|Ton-BitCoin
|ˢTBC|0.16777216|100|San-Bitcoin
|ᵐTBC|2.68435456|1000|Mill-BitCoin
|ᵇTBC|42.94967296|1,0000|Bong-BitCoin
||2,814,749.76710656|1,0000,0000|Tam-BitCoin

<small>* Tonal BitCoin and Decimal BitCoin can be differentiated by the pronunciation of the numbers. "One bitcoin", "two bitcoin", etc is decimal, but "an bitcoin", "de bitcoin" is tonal.</small>

The total number of Tonal BitCoins ever (analogous to the 21mil BTC) is just over 7.75059 tam-bitcoin.

For more information on the Tonal system in general, please see [the book](http://www.lulu.com/product/file-download/tonal-system/10991091).

## Compatible Clients

While all BitCoin clients will correctly approximate values in decimal bitcoin, actual Tonal compatibility is sparse.

* [[Spesmilo]], despite its name, can be configured to display TBC

## Guessing TBC or BTC

Given variable 'value' in base units (uBTCents/TBCᵇ), one can guess whether it is properly Decimal BitCoin or Tonal BitCoin with the following pseudo-code:

	if ( ! ( this % 0x10000 ) )
	Choose Tonal BitCoin
	if ( ! ( this % 1000000 ) )
	Choose Decimal BitCoin
	if ( ! ( this % 0x100 ) )
	Choose Tonal BitCoin

### Python

<pre>import math

def formatBTC(n, addSign = False):
	s = "%0.2f BTC" % (math.ceil(n * 100) / 100.,)
	if addSign and n >= 0:
		s = "+" + s
	return s

def Bitcoin2BTC(n):
	return n / 100000000.

toTonalDict = dict(((57, u'\ue9d9'), (65, u'\ue9da'), (66, u'\ue9db'), (67, u'\ue9dc'), (68, u'\ue9dd'), (69, u'\ue9de'), (70, u'\ue9df'), (97, u'\ue9da'), (98, u'\ue9db'), (99, u'\ue9dc'), (100, u'\ue9dd'), (101, u'\ue9de'), (102, u'\ue9df')))

def formatTBC(n, addSign = False):
	s = "%x" % n
	n %= 1
	if n:
		s += '.'
		while n:
			n *= 16
			s += "%x" % n
			n %= 1
	s = unicode(s).translate(toTonalDict)
	s += " TBC"
	if addSign and n >= 0:
		s = "+" + s
	return s

def Bitcoin2TBC(n):
	return n / 65536.

def formatBitcoin(n, addSign = False):
	if not n % 0x10000:
		return formatTBC(Bitcoin2TBC(n), addSign);
	if not n % 1000000:
		return formatBTC(Bitcoin2BTC(n), addSign);
	if not n % 0x100:
		return formatTBC(Bitcoin2TBC(n), addSign);
	s = "%d uBTCents" % (n,);
	if addSign and n > 0:
		s = "+" + s;
	return s;</pre>

## Criticism

All irrational/emotional resistance to change, so far. (if you disagree, put a RATIONAL argument here)

[[!tag "_Nonsensical_and_useless_ways_to_represent_quantities_of_Bitcoins"]]
