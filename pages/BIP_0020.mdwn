This is about creating a URI scheme for bitcoin.
Previous discussion in the forum http://www.bitcoin.org/smf/index.php?topic=55.0
x-btc specification at http://pastebin.com/VsBbmXQx

##RFC 3986
**the following is taken from wikipedia**

Internet standard [STD 66](http://rfc.net/std0066.html) (also RFC 3986) defines the generic syntax to be used in all URI schemes. Every URI is defined as consisting of four parts, as follows:

	<code><nowiki><scheme name> : <hierarchical part> [ ? <query> ] [ # <fragment> ]</nowiki></code>

The **scheme name** consists of a letter followed by any combination of letters, digits, and the plus ("+"), period ("."), or hyphen ("-") characters; and is terminated by a colon (":").

The **hierarchical part** of the URI is intended to hold identification information hierarchical in nature. Usually this part begins with a double forward slash ("//"), followed by an *authority* part and an optional *path*.  

* The **authority** part holds an optional user information part terminated with "@" (e.g. <code><nowiki>username:password@</nowiki></code>), a hostname (i.e. domain name or IP address), and an optional port number preceded by a colon ":".

* The **path** part is a sequence of segments (conceptually similar to directories, though not necessarily representing them) separated by a forward slash ("/"). Each segment can contain parameters separated from it using a semicolon (";"), though this is rarely used in practice.

The **query**  is an optional part separated with a question mark, which contains additional identification information which is not hierarchical in nature. The query string syntax is not generically defined, but is commonly organized as a sequence of <code><nowiki><key>=<value></nowiki></code> pairs separated by a semicolon (2.1) (2.2) (2.3) or separated by an ampersand, for example:
	Semicolon: <code><nowiki>key1=value1;key2=value2;key3=value3</nowiki></code>
	Ampersand: <code><nowiki>key1=value1&key2=value2&key3=value3</nowiki></code>

The **fragment** is an optional part separated from the front parts by a hash ("#"). It holds additional identifying information that provides direction to a secondary resource, e.g. a section heading in an article identified by the remainder of the URI.  When the primary resource is an HTML document, the **fragment** is often an <code>id</code> attribute of a specific element and web browsers will make sure this element is visible.

##tcatm

I propose a scheme like this:

() means optional, $* are placeholders

<pre>
bitcoin:($label@)$address(?$query)(#$message)
</pre>

### Variables

<pre>
label: Label for that address (e.g. name of receiver)
address: bitcoin address
query: pairs of key=value seperated by &
message: optional message that is shown to the user after scanning the QR code
</pre>

### Query keys
<pre>
amount: amount of BTC

</pre>
### Examples

Just the address:
<pre>
bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt
</pre>

Address with name:
<pre>
bitcoin:tcatm@18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt
</pre>

Request to send 20.30 BTC to me:
<pre>
bitcoin:tcatm@18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt?amount=20.30
</pre>

Request to send 50 BTC with message:
<pre>
bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt?amount=50#Payment%20for%20product%20xyz
</pre>

Characters must be URI encoded.



##tcatm, modified by LukeJr

I propose a scheme like this:

[] means optional, <> are placeholders

	bitcoin:<address>?amount=<size><unit><label>[[&label=]]<message>[[&message=]]

### Variables

* label: Label for that address (e.g. name of receiver)
* address: bitcoin address
* message: optional message that is shown to the user after scanning the QR code
* size: amount of $unit
* unit: BTC, [[ᵗˢᵐᵇ]]TBC[[ᵗˢᵐᵇ]], or null/omitted (which refers to the base unit)

### Examples

Just the address:
	bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt

Address with name:BTC
	bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt?label=tcatm

Request to send 20.30 BTC to tcatm:
	bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt?amount=20.30BTC&label=tcatm

Request to send 400 TBC to Luke:
	bitcoin:1KczVqwopWXQdFLe5sNQbpCq7yGSmXx2oo?amount=400TBC

Request to send 5 uBTC:
	bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8q9ztaWWXt?amount=500

Request to send 50 BTC with message:
	bitcoin:18pnDgDYFMAKsHTA3ZqyAi6t8qztaWWXt?amount=50BTC&label=tcatm&message=Payment%20for%20product%20xyz

Characters must be URI encoded properly.

### BNF syntax

	bitcoinurn      = "bitcoin:" bitcoinaddress  [bitcoinversion](";version=")  [bitcoinparams]("?")
	bitcoinaddress  = FIXME :)
	bitcoinversion  = "1.0"
	bitcoinparams   = *bitcoinparam
	bitcoinparam    = amountparam  labelparam  messageparam
	amountparam     = "amount=" amount
	amount          = amountdecimal  amounthex  amounttonal
	amountdecimal   = digits btcunits
	amounthex       = "x" hexdigits bitcoinunit
	amounttonal     = tonaldigits tbcunits
	bitcoinunit     = btcunits  tbcunits
	btcunits        = "BTC"  "BTCents"  "uBTC"  "uBTCents"
	tbcunits        = tbcunitsunicode  tbcunitsascii  tbcunitsfull
	tbcunitsunicode = "ᵇTBC"  "ᵐTBC"  "ˢTBC"  "ᵗTBC"  "TBC"  "TBCᵗ"  "TBCˢ"  "TBCᵐ"  "TBCᵇ"
	tbcunitsascii   = "bTBC"  "mTBC"  "sTBC"  "tTBC"  "TBC"  "TBCt"  "TBCs"  "TBCm"  "TBCb"
	tbcunitsfull    = "tran-TBC"  "song-TBC"  "tam-TBC"  "bong-TBC"  "mill-TBC"  "san-TBC"  "ton-TBC"  "TBC"  "TBC-ton"  "TBC-san"  "TBC-mill"  "TBC-bong"
	labelparam      = "label=" *uchar
	messageparam    = "label=" *uchar


##marcusaurelius

###payment identifiers, not person identifiers
in my opinion, the most basic idea of the URI scheme (as this is a currency) is to facilitate payment. so the URIs should represent first and foremost payments. if it represents something else, this needs to be specified. Thus
<code>
bitcoin:13guMzcGPvdD3qjQvCoNc1w5XAgJ638KaQ
</code>
represent a **payment** to me using my bitcoin adress, not my bitcoin adress itself. So after parsing the URI (via link/qr/whatever) the application should open a transaction window with the adress filled in. you then need to add an amount and confirm the payment.
If your application is smart, it will also have a button "just store the adress". But the point i am trying to make, is that the default use of the URI should be for payment, nor for exchanging adresses.

###accessibility
**imported from the forum:** I like the simplicity of bitcoin:xxxxxxxxxxxxx plus very much approve of its accessibility. Should someone from the outside happen to see such a uri, the protocol name already gives a description. A quick google search should then do the rest. x-btc sounds much more cryptic, the chance that s/1 gooogles that out of curiosity are much slimmer. Also, very likely, what s/he will find are mostly technical specifications. Not a good introduction to bitcoin.

for the same reason i am for using '&' as a delimiter for key-value-pairs. people know it from urls. make it easy for people to understand what is going on.

###keep it simple
don't explicitly write down information that can be inferred. don't mark the address as an address. if there is no address, this does lose much of its utility. we could, however, specify 'address' as a reserved word, so that <code>
bitcoin:address?amount=50
</code>
would initiate a transaction with the amount filled in, but with a blank address. I am not convinced that there is a use case, though.

###use-cases
before the URI scheme is finalised one should think long and hard about use-cases. in what circumstances will who use this for what?

###backwards-compatibility
we want URIs generated in 2011 to still work in 2036. think about extensibility. of course we can make only educated guesses (and nothing more!) about the future, but don't act as if there is none. this should be the best we can do, but it should not be seen as forever set in stone. make it possible for later generations to improve our work, to mend our errors, without breaking the URIs created now. Version incompatibility is the easiest thing to drive users crazy: "i now upgraded to this shiny new version. what? it doesn't support the old format? AAAAAAARRRGH!"

##References

<span class="ref-label">2.1:
<span class="ref-column">
 
RFC 1866 section 8.2.1 : by Tim Berners-Lee in 1995 encourages CGI authors to support ';' in addition to '&'.
</span>  
<span class="ref-label">2.2:
<span class="ref-column">
 [HTML 4.01 Specification: Implementation, and Design Notes](http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.2) 
: "CGI implementors support the use of ";" in place of "&" to save authors the trouble of escaping "&" characters in this manner."
</span>  
<span class="ref-label">2.3:
<span class="ref-column">
 [Hypertext Markup Language - 2.0](http://www.w3.org/MarkUp/html-spec/html-spec_foot.html#FOOT26) 

"CGI implementors are encouraged to support the use of ';' in place of '&' " 
</span>

