This is a project to define a new wallet protocol addressing problems with the current JSON-RPC implementation in bitcoind.
Please feel free to make edits. If you disagree with something, turn it into a "debate".

## Explanation
This protocol aims to be a standard for communication between Wallets and User Interfaces.
It can be used to access a Wallet remotely, or even locally, even if the Wallet and User Interface are produced by different or competing vendors. For example, you could use an Android User Interface from Google to control a QBitcoin Wallet.

Please see the [[Infrastructure]] page for an overview of where this protocol fits into the big picture.

## Requirements

* Never use human-formatted data (for example, use base bitcoin units, not Decimal BitCoins nor Tonal BitCoins, which should only be used in formatting for humans)
* Don't require polling (for example, broadcast events for new transactions, or changes to current "work")
* Cooperative mining (see below)
* Allow calculating expected minimum fee for transactions, with either (wallet's choice) locking on the used inputs, or prebuilding the tx and error if it becomes invalid before sending
* Easy to use in a RPC-like manner, for simple applications

### Debates
#### Binary or plaintext

* Binary is more efficient to parse and create
* Plaintext is easier for humans to debug
* Binary can include custom transactions as-is for transmission
* Protobuf (binary) seems efficient and easy to use from all major languages
* JSON implementations tend to be buggy

### Cooperative mining
The protocol should support submitting completed blocks, such that it can get (just) addresses from an upstream pool to generate to, and send all completed blocks to that pool for verification and counting (and possibly submission to the network). This can reduce the pool's load.

### UI bundling
For more secure use by ordinary end users, UIs and Wallets should support communication over standard I/O (stdio). This allows the UI to simply execute a dedicated Wallet, without requiring the user to setup Wallet-side authentication.

# DRAFT 0
Everything beyond this point is strictly DRAFT, should NOT be implemented, and is subject to being completely rewritten or modified!

## Conformance requirements

All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.

The key words "MUST", "MUST NOT", "REQUIRED",  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification.

Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc) used in introducing the algorithm.

## Transport Layer
Must support at least reliable in-order stream data.

Such as:

* stdio (required for self-contained UI bundling)
* TLS (recommended)
* TCP (NOT recommended; see TLS)
* SSH

## Session Layer
HTTP or SPDY

## Presentation Layer
HTTP-with-SSE request semantics

### Formats
These content types may be specified in the Content-Type header, and Accept header.

* application/x-ripemd-160 (required)
* application/x-sha (required)
* multipart/mixed (required)
* text/event-stream (required for events over HTTP)
* application/x-bitcoin (required wallet-side)
* application/json (recommended)
* application/xml

## Application Layer
### Security
Wallets may micro-manage security as they like, but the following are RECOMMENDED security levels:

|"Miner" |Can generate new addresses, get work, and report found blocks
|Read-only |Can view accounts, addresses, and any public data, and combinations thereof (eg, balances)
|Financial |Can create new transactions using the wallet's keys
|Full |Can administrate (download, destroy, etc) wallet keys


### Object/Query Schema
May be provided in multipart/mixed, JSON, XML, etc...



|id|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|Unique data identifier; only guaranteed to remain the same for a single session
|type|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|Type of data: 'key', 'tx', 'block', 'account', 'accounting'
|hash|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]
|size|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_unknown]]|[[!template id=table_value_yes]]|[[!template id=table_value_unknown]]|[[!template id=table_value_yes]]
|time|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]
|difficulty|[[!template id=table_value_yes]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]
|related|[[!template id=table_value_yes]]|[[!template id=table_value_yes]]|[[!template id=table_value_unknown]]|[[!template id=table_value_unknown]]|[[!template id=table_value_unknown]]|[[!template id=table_value_unknown]]|Can have multiple entries (in JSON, an array value)
|coinbase|[[!template id=table_value_no]]|[[!template id=table_value_yes]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]
|inputs|[[!template id=table_value_no]]|[[!template id=table_value_yes]]|[[!template id=table_value_unknown]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]
|outputs|[[!template id=table_value_no]]|[[!template id=table_value_yes]]|[[!template id=table_value_unknown]]|[[!template id=table_value_no]]|[[!template id=table_value_no]]|[[!template id=table_value_yes]]


### Data

* Arbitrary data can be accessed with the path /data/<id>
* GET to fetch
* To get only block header, use /data/<id>/header
* To get only actual content (eg, no calculated values), use /data/<id>/raw
* Optional: PUT to upload

### Requests
#### Data Search

* GET /dataSearch?<query-object>
* POST /dataSearch allowed for more complex queries

NOTE: To get the id rather than the data itself, use a HEAD request and check the Location header.

#### Monitor Events

* Always POST

##### New Data Available

* Query

### Events
#### New Data Available

### p2p protocol encapsulation
Optional: Establish a WebSocket connection to /p2p to speak direct p2p protocol

## References
<references>
 (25.1)
 (25.2)
 (25.3)
 (25.4)
 (25.5)
</references>
25.1: [Key words for use in RFCs to Indicate Requirement Levels](http://tools.ietf.org/html/rfc2119) , S. Bradner. IETF.  
25.2: [Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616) , Fielding, et al, W3C.  
25.3: [The application/json Media Type for JavaScript Object Notation (JSON)](http://tools.ietf.org/html/rfc4627) , D. Crockford. JSON.org.  
25.4: [Server-Sent Events](http://dev.w3.org/html5/eventsource/) , Ian Hickson, Google, Inc.  
25.5: [SPDY Protocol](http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2) , various. Google, Inc.
